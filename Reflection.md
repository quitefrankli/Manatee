## What Designs Am I Happy With?

1. `GraphicsBuffer` + `GraphicsBufferManager`.

	* Strong separation between Data and Function makes for clean logic
	* Singular purpose, `GraphicsBuffer` is just an abstraction over a contiguous block of memory, `GraphicsBufferManager` is just a manager for the memory
	* Nice interface, using inheritance here such that `GraphicsResourceManager` inlines the public interface of the `GraphicsBufferManager` makes usage of the manager extremely concise, no need to request the buffer manager and it makes sense as the buffer manager is part of the resource manager itself.
	* Easily extensible, adding additional buffers was a breeze as it follows the *Open-Closed-Principle*.
	* Lots of unit tests and clear TDD engineering was followed.
	* Realtime visualisable buffer fill/capacity means there's lots of feedback.

2. `Renderer`/`Pipeline` classes.

	* Each renderer/pipeline is only responsible and does 1 thing.
	* Easily extensible, many additional pipelines and renderers were added without much refactoring.
	* Small interface, not much needs to be exposed. So it's considered a "deep" interface as opposed to a "shallow" one which is universally good.

3. Strong separation between `GraphicsEngine` and rest of code.

	* There's no mention of vulkan outside of the `GraphicsEngine` so code complexity is reduced
	* Makes it easier to integrate multiple graphics APIs


## What Designs Was/Am I Unhappy With?

1. OOP Style objects, too many different classes are required to deal with the mixed variety of Object types, i.e. *base_objs*, *clickable_objs*, *light_source_objs*, *clickable_light_source_objs*. Each required it's own separate class and this was clearly unscalable. ECS will probably be the right approach going forward.

2. ~~`Shape` class only supporting 2D shapes with `Object` class supporting composition of `Shape`. This was terrible as this was never a good separation and really only worked with extremely simple shapes like cubes and convex polyhedrons. With complicated meshes like humanoids this completely falls apart.~~ -> Solution was to treat shape as 3D mesh.

3. ~~Every procedurally generated mesh having its own class i.e. `CircleShape`, `SquareShape`, `ArrowShape` (even worse, this was applied to some objects `CubeObject`). This caused too many identical looking classes that spammed the code with functionally few differences and was a nightmare to maintain.~~ -> Solution was to have good separation between Data and Function, a `ShapeFactory` was introduced that generated the `Shape` and a constructor was added to `Object` such that it could be constructed with a `Shape` generated by the factory.


## What Designs Am I On the Fence About?

1. Templating the `GraphicsEngine`. 
   
   The main advantages were: 
	* Allowing some unittests to be written without involving the GPU.
	* Supporting potential future endeavors with multiple graphics APIs.

	However there were alot of drawbacks as well:

	* It took considerable effort and is an omnipresent forever hindrance for code development.
	* It's still not possible to write unittests for the graphics engine
	* Templating the `GraphicsEngine` means that the `GameEngine` itself had to be templated as well.
	* Is there ever a need to support multiple graphics APIs?
	* Code bloat.
	* Slower compile times.

2. `GraphicsEngineBaseModule` design pattern.
   
	Advantages:
	* Very easy access to every possible Vulkan related abstraction/object i.e. logical device and buffers

	Disadvantages:
	* Code bloat.
	* Tight coupling between graphics engine and graphics engine modules.


## Principles I Followed/Plan on Following

* Dedicate time early on to designing interfaces before implementation, good interfaces/abstractions can be monumental
* Move fast and break things, as the engine grows more and more complexity will be introduced if on every feature we go through and make sure every niche component doesn't break then this will become an exponentially compounding time drain. Instead by fixing things when needed and only in between multiple features, we can potentially save time on potential redesigns